# 切片

# 为什么切片和区间会忽略最后一个元素
# 在切片和区间操作里不包含区间范围的最后一个元素是 python 的风格,这个习惯符合 python, c 和其他语言里以 0 作为起始下标的传统.
# 这样做的好处如下:
# 当只有最后一个位置信息时,我们可以快速看出切片和区间里有几个元素
# 当起止位置信息可见时,我们可以快速计算出切片和区间的长度,用后一个数减去第一个下标即可.
# 这样做也让我们利用任意一个下标把序列分割成不重叠的两部分

l = [10, 20, 30, 40, 60, 50]
# print(l[:2])
#
# print(l[2:])
# print(l[:3], l[3:])

# 2.4.2
# 对对象进行切片
# 一个众所周知的秘密是, 我们还可以用 s[a:b:c]的形式对s 在a 和 b 之间以 c 为间隔取值.c 的值还可以为负,负值意味着反向取值.
s = 'bicycle'
# print(s[::3],s[::-1], s[::-2])

# a:b:c这种用法只能作为索引或者下标用在[]中来返回一个切片对象: slice(a,b,c).

# 多维切片和省略

# 省略的正确书写方法是三个英语句号(...),而不是 unicode 码位 u+2026 表示的半个省略号(...)

# 给切片赋值
# 如果赋值的对象是一个切片,那么赋值语句的右侧必须是个可迭代对象.即便只有单独一个值,也要把它转换成可迭代的序列.


# 对序列使用+和*
# python 程序员会默认序列是支持+和*操作的.通常+号两侧的序列由相同的数据所构成,在拼接的过程中,两个被操作的序列都不会被修改,python 会新建
# 一个包含同样类型数据的序列来作为拼接的结果.
# + 和 * 都遵循这个规律,不修改原有的操作对象,而是构建一个全新的序列.

my_list = [[]] * 3
# print(my_list, id(my_list[0]), id(my_list[1]))
# my_list 列表里包含的 3 个元素其实是 3 个引用,而且这 3 个引用指向的都是同一个列表.

# 序列的增量赋值
# += 背后的特殊方法是__iadd__.但是如果一个类没有实现这个方法的话,python 会退一步调用__add__

# 边界情况

t = (1,2,[10,20])
t[2] += [50,60]
print(t)

# python tutor 是一个对 python 运行原理进行可视化分析的工具
# 总结 3 个教训
# 不要把可变对象放在元组里面
# 增量赋值不是一个原子操作,我们刚才也看到了,它虽然抛出了异常,但还是完成了操作.
# 查看 python 的字节码并不难,而且它对我们了解代码背后的运行机制很有帮助.